# ASP.NET Core搭配EFCore範例

本方案用以演示使用ASP.NET Core搭配Entity Framework Core 3撰寫簡易的API，實際使用LINQ操作資料庫內容與查詢。

## 專案介紹

1. Learning_EFCore: API主專案
2. Learning_EFCore.Database: EntityFrameworkCore專案

## 所需工具

* [EF Core Power Tools](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EFCorePowerTools): 為Visual Studio工具，便於操作EFCore對現有資料庫的逆向工程，簡易實現DB First，且自動安裝相關EFCore套件。可參考[這篇文章](https://marcus116.blogspot.com/2019/04/netcore-entity-framework-core-ef-core.html)

## 專案參考

Learning_EFCore參考Learning_EFCore.Database專案
本範例使用PostgreSQL資料庫，可視情況調整為SQL Server

> 請安裝[Npgsql PostgreSQL Integration](https://marketplace.visualstudio.com/items?itemName=RojanskyS.NpgsqlPostgreSQLIntegration)才可在EF Power Tools中使用PostgreSQL資料來源。

## 關於資料庫連線字串設定

本範例的資料庫連線字串取自`appsettings.json`中的`ConnectionStrings`的`Default`，請依自己的測試資料庫變更相應的資料庫。

測試資料庫的資料表建立的PostgreSQL腳本如下(視情況自行調整為自己測試資料庫的類型):

```sql
CREATE TABLE public.article (
	id int4 NOT NULL GENERATED BY DEFAULT AS IDENTITY,
	category_id varchar(128) NOT NULL,
	title varchar(255) NOT NULL,
	tags _text NULL,
	author_name varchar(255) NULL,
	create_time timestamptz NOT NULL,
	modify_time timestamptz NOT NULL,
	published bool NOT NULL,
	content_type text NOT NULL,
	"content" text NOT NULL,
	summary text NULL,
	cover_url text NULL,
	old_id uuid NULL,
	CONSTRAINT pk_article_id PRIMARY KEY (id)
);

CREATE TABLE public.article_category (
	id varchar(128) NOT NULL,
	"name" varchar(255) NOT NULL,
	sort int4 NOT NULL,
	summary text NULL,
	CONSTRAINT pk_article_category_id PRIMARY KEY (id)
);
```

## 在API專案中加入EFCore的DI項目

接下來於`Startup`中的`ConfigureServices`方法中加入以下程式:

```csharp
// 引入EFCore DI
services.AddDbContext<Profiles2Context>(config =>
{
    // 自appsettings.json取出並設定連線字串
    config.UseNpgsql(Configuration.GetConnectionString("Default"));
});
```

以上就成功將EFCore加入專案。

## 在Controller中使用EFCore的DbContext

DbContext為EFCore存取資料庫的主體，我們在前一個步驟已經將其加入專案的DI中，在本範例中先不把商業邏輯抽出單一類庫。

在本範例中將直接在Controller透過DI取得DbContext。

請建立一個空Controller為ArticleController，且建立一建構子取得DbContext。

建立後大概如下:

```csharp
[ApiController]
[Route("api/[controller]")] // 設定該Controller路由
public class ArticleController : ControllerBase
{
    public Profiles2Context Context { get; set; }
    public ArticleController(Profiles2Context context)
    {
        Context = context;
    }
}
```

## 建立簡單的LIST API

列出所有文章，則直接將Context內的DbSet直接回傳即可，DbSet也為IQueryable類型。

```csharp
[HttpGet("all")] //   /api/article/all
public IEnumerable<Article> ListAllArticle()
{
    return Context.Article;
}
```

## 建立分頁的LIST API

上列全部列出API在數據多時會遇到資料量太大的問題，所以這邊使用LINQ的SKIP與TAKE，讓EF轉譯為SQL中對應的語法，取得指定區間的資料列。

首先先建立一個`PaggingOf<T>`的類型，這邊是為了同時提供API用戶總資料筆數。
```csharp
public class PaggingOf<T>
{
    public IEnumerable<T> Result { get; set; }
    public int TotalCount { get; set; }
}
```

接下來建立新API如下:

```csharp
[HttpGet] //  /api/article?offset=0&limit=10
public PaggingOf<Article> PaggingOfArticle(
	int offset = 0,
	int limit = 10)
{
    return new PaggingOf<Article>()
    {
        Result = Context.Article.OrderBy(x => x.Id).Skip(offset).Take(limit),
        TotalCount = Context.Article.Count()
    };
}
```

如此用戶取得目前分頁結果也可以同時取得資料總筆數。

> 分頁資料請記得排序。

## 分頁列表API綜合查詢條件

通常在列表相關API會復合關鍵字查詢功能，而在這個範例中我們希望能夠使用關鍵字搜尋文章的標題與內容。

所以我們將利用建立一個IQueryable變數，用以暫存查詢並加以包裝。

```csharp
[HttpGet]
public PaggingOf<Article> PaggingOfArticle(
    string q,
    int offset = 0,
    int limit = 10)
{
    IQueryable<Article> result = Context.Article;
    if (!string.IsNullOrWhiteSpace(q))
    {
        result = result.Where(x => x.Title.Contains(q) || x.Content.Contains(q));
    }

    result = result.OrderBy(x => x.Id);

    return new PaggingOf<Article>()
    {
        Result = result.Skip(offset).Take(limit),
        TotalCount = result.Count()
    };
}
```

值得留意的是，回傳的Total必須要使用result的Count，因為API用戶必須知道的是這次查詢過濾的總筆數，而非沒過濾的總數。

## 取得單筆資料

```csharp
[HttpGet("{id}")] //  /api/article/100
public Article GetArticle(int id)
{
    return Context.Article.FirstOrDefault(x => x.Id == id);
}
```

## 刪除資料

```csharp
[HttpDelete("{id}")] //  /api/article/100
public void DeleteArticle(int id)
{
    var target = Context.Article.FirstOrDefault(x => x.Id == id);
    if (target == null) return;
    Context.Article.Remove(target);
    Context.SaveChanges();
}
``` 

## 批次刪除資料

若要刪除符合特定條件的資料，可以使用下列方法實現。

```csharp
Context.Article.RemoveRange(Context.Article.Where(x=>x.Id % 2 == 0));
Context.SaveChanges();
```

## 更新資料

在EFCore取出的物件，若是沒有進行特別設定，則都會被EF追蹤異動，只要異動後調用SaveChanges就會更新資料庫。

```csharp
[HttpPut] //  /api/article/
public Article UpdateArticle([FromBody] Article article)
{
    var target = Context.Article.FirstOrDefault(x => x.Id == article.Id);
    if (target == null) return null;
    target.Title = article.Title;
    target.Content = article.Content;

    Context.SaveChanges();
    return target;
}
```

## 批次更新資料

EF並不支援批次更新資料，若要在EF中更新大量的資料則需要使用For迴圈逐一取出更新，但這樣的效率低下，但我們可以利用額外的套件實現此一功能。

請在API專案安裝`linq2db.EntityFrameworkCore`套件，該套件為linq2db的實現。

這個套件的詳細使用可以見[README](https://github.com/linq2db/linq2db.EntityFrameworkCore)。

可以使用以下方式針對特定條件的資料做批次更新。

```csharp
Context.Article.Where(x => x.Id % 2 == 0)
    .Set(x => x.Title, x => "UPDATE_" + x.Title)
    .Update();
```